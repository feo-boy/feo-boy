//! Audio playback functionality.
//!
//! Plays the audio based on the state of the sound hardware.

use std::sync::Arc;

use anyhow::{anyhow, Result};
use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};
use cpal::{OutputCallbackInfo, SampleFormat, Stream};
use derivative::Derivative;
use log::*;

use crate::cpu;

use super::SampleBuffer;

/// Outputs PCM audio generated by the sound controller.
#[derive(Derivative)]
#[derivative(Debug)]
pub struct Output {
    /// The audio output stream.
    #[derivative(Debug = "ignore")]
    stream: Stream,

    /// Queued raw emulated PCM audio samples.
    pub sample_buffer: SampleBuffer,
}

impl Output {
    pub fn new() -> Result<Self> {
        let device = cpal::default_host()
            .default_output_device()
            .ok_or_else(|| anyhow!("no audio output devices found"))?;

        let sample_buffer = SampleBuffer::default();

        let config = device
            .supported_output_configs()?
            .find(|config| config.channels() == 1 && config.sample_format() == SampleFormat::F32)
            .map(|config| config.with_max_sample_rate())
            .ok_or_else(|| anyhow!("no supported audio output configuration found"))?
            .config();

        info!("initializing audio playback with {:?}", config);

        let skipped_samples = (cpu::FREQUENCY / config.sample_rate.0) as usize;

        let stream_buffer = Arc::clone(&sample_buffer);
        let stream = device.build_output_stream(
            &config,
            move |dst: &mut [f32], _: &OutputCallbackInfo| {
                let mut src = stream_buffer.lock().unwrap();

                // Naive nearest-neighbor downsampling
                for sample in dst.iter_mut() {
                    *sample = src.pop_front().unwrap_or(0.0);

                    for _ in 0..skipped_samples {
                        src.pop_front();
                    }
                }

                // FIXME: There are extra samples left over here, and the number of skipped
                // samples isn't quite accurate. If we were a bit more accurate here, we might be
                // able to fix some crackles in the output.
            },
            |err| panic!("{}", err),
            None,
        )?;

        stream.play()?;

        Ok(Output {
            stream,
            sample_buffer,
        })
    }
}
