//! Implementation of the Game Boy sound hardware.
//!
//! Detailed information about this component can be found on the [Gameboy sound hardware page of
//! the GB dev wiki][sound hardware wiki].
//!
//! [sound hardware wiki]: https://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware

use std::collections::VecDeque;
use std::convert::TryInto;
use std::sync::{Arc, Mutex};

use anyhow::Result;

use crate::bytes::ByteExt;
use crate::cpu;
use crate::memory::Addressable;
use crate::TCycles;

mod output;

use output::Output;

/// Shared buffer containing PCM audio samples generated by the emulator to be sent to the audio
/// device.
type SampleBuffer = Arc<Mutex<VecDeque<f32>>>;

/// Four available square wave duty cycles.
const DUTY: [[u8; 8]; 4] = [
    [0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 1, 1, 1],
    [0, 1, 1, 1, 1, 1, 1, 0],
];

/// Generates clocks for the other modulation units.
#[derive(Debug)]
struct FrameSequencer {
    timer: u32,
}

impl FrameSequencer {
    fn new() -> FrameSequencer {
        FrameSequencer { timer: 0 }
    }

    /// Ticks the frame sequencer a single cycle.
    ///
    /// If the step value of the sequencer has changed since the last call, returns the new value.
    fn step(&mut self) -> Option<u8> {
        const FREQUENCY: u32 = cpu::FREQUENCY / 512;

        let step = if self.timer % FREQUENCY == 0 {
            Some(
                (self.timer / FREQUENCY)
                    .try_into()
                    .expect("step must be between 0 and 7"),
            )
        } else {
            None
        };

        self.timer += 1;

        if self.timer == FREQUENCY * 8 {
            self.timer = 0;
        }

        step
    }
}

/// The sweep register data for a channel.
#[derive(Debug, Default)]
pub struct Sweep {
    /// The sweep time.
    pub time: u8,

    /// Whether the sweep increases (if false) or decreases (if true) the frequency.
    pub decrease: bool,

    /// The sweep shift number.
    pub shift: u8,
}

impl Sweep {
    /// Gets the result of reading the sweep register for the current sweep state.
    pub fn read(&self) -> u8 {
        let mut byte = self.time << 4;
        byte |= self.shift;
        byte.set_bit(3, self.decrease);

        byte
    }

    /// Modifies the sweep state according to the written byte.
    pub fn write(&mut self, byte: u8) {
        self.shift = byte & 0x7;
        self.decrease = byte.has_bit_set(3);
        self.time = (byte >> 4) & 0x7;
    }
}

/// The sound length/wave pattern duty for a channel.
#[derive(Debug, Default)]
pub struct Wave {
    /// Wave pattern duty (0-3).
    pub pattern: u8,

    /// Sound length (0-63).
    pub length_load: u8,

    length: u8,

    enabled: bool,
}

impl Wave {
    /// Gets the result of reading the wave register for the current register state.
    pub fn read(&self) -> u8 {
        let mut byte = self.pattern << 6;
        byte |= self.length_load;

        byte
    }

    /// Modifies the wave state according to the written byte.
    pub fn write(&mut self, byte: u8) {
        self.pattern = byte >> 6;
        self.length_load = byte & 0x3F;
        self.length = 64 - self.length_load;
    }

    /// Clocks the length counter. Returns `true` if the counter reaches zero.
    fn step(&mut self) -> bool {
        if self.length > 0 && self.enabled {
            self.length -= 1;
        }

        if self.length == 0 {
            self.enabled = false;
            true
        } else {
            false
        }
    }
}

/// The volume envelope for a channel.
#[derive(Debug, Default)]
pub struct Envelope {
    /// The initial volume of the envelope (0-15).
    pub initial_vol: u8,

    /// The direction of the envelope - `true` means increase, `false` means decrease.
    pub direction_increase: bool,

    /// Number of envelope sweep (0-7). The length of one step of the sweep is n * (1/64).
    pub number: u8,

    /// Whether the unit should update the volume on the next step.
    disabled: bool,

    counter: u8,

    volume: u8,
}

impl Envelope {
    /// Gets the result of reading the envelope register for the current register state.
    pub fn read(&self) -> u8 {
        let mut byte = self.initial_vol << 4;
        byte.set_bit(3, self.direction_increase);
        byte |= self.number;

        byte
    }

    /// Modifies the envelope state according to the written byte.
    pub fn write(&mut self, byte: u8) {
        self.initial_vol = byte >> 4;
        self.direction_increase = byte.has_bit_set(3);
        self.number = byte & 0x7;
    }

    fn step(&mut self) {
        if self.number != 0 {
            self.counter += 1;

            if self.counter >= self.number {
                let new_volume = if self.direction_increase {
                    Some(self.volume + 1)
                } else {
                    self.volume.checked_sub(1)
                };

                match new_volume {
                    Some(new_volume) if new_volume <= 15 => self.volume = new_volume,
                    _ => self.disabled = true,
                }

                self.counter = 0;
            }
        }
    }
}

/// The frequency data for a channel.
#[derive(Debug, Default)]
pub struct Frequency {
    /// Initial (`true` = restart sound) (Write only).
    pub initial: bool,

    /// Counter/consecutive selection (`true` = stop output when length in wave pattern duty
    /// expires).
    pub counter: bool,

    /// The 11-bit frequency (Write only).
    pub frequency: u16,
}

impl Frequency {
    /// Modifies the lower 8 bits of the 11-bit frequency according to the written byte.
    pub fn write_lo(&mut self, byte: u8) {
        self.frequency = (self.frequency & 0xFF00) | u16::from(byte);
    }

    /// Gets the result of reading the high bits of the frequency data.
    pub fn read_hi(&self) -> u8 {
        let mut byte = 0xFF;
        byte.set_bit(6, self.counter);

        byte
    }

    /// Modifies the high bits of the frequency data according to the written byte.
    pub fn write_hi(&mut self, byte: u8) {
        self.initial = byte.has_bit_set(7);
        self.counter = byte.has_bit_set(6);
        self.frequency = ((u16::from(byte & 0x7)) << 8) | (self.frequency & 0xFF);
    }
}

/// The sound length for channel 3.
#[derive(Debug, Default)]
pub struct BigLength {
    /// Sound length (0-255)
    pub length: u8,
}

// TODO test
impl BigLength {
    /// Gets the result of reading the BigLength register for the current register state.
    pub fn read(&self) -> u8 {
        self.length
    }

    /// Modifies the BigLength state according to the written byte.
    pub fn write(&mut self, byte: u8) {
        self.length = byte;
    }
}

/// The output level.
#[derive(Debug, Default)]
pub struct OutputLevel {
    /// The output level (0-3).
    pub output_level: u8,
}

// TODO test
impl OutputLevel {
    /// Gets the result of reading the output level for the current register state.
    pub fn read(&self) -> u8 {
        self.output_level
    }

    /// Modifies the output level state according to the written byte.
    pub fn write(&mut self, byte: u8) {
        self.output_level = (byte >> 5) & 0x3;
    }
}

/// The sound length for channel 4.
#[derive(Debug, Default)]
pub struct Length {
    /// Sound length (0-63).
    pub length: u8,

    enabled: bool,
}

// TODO test
impl Length {
    /// Gets the result of reading the length register for the current register state.
    pub fn read(&self) -> u8 {
        self.length
    }

    /// Modifies the length state according to the written byte.
    pub fn write(&mut self, byte: u8) {
        self.length = byte & 0x3F;
    }
}

/// The polynomial counter for channel 4.
#[derive(Debug, Default)]
pub struct PolynomialCounter {
    /// The shift clock frequency.
    pub shift_clock_frequency: u8,

    /// Counter step/width (false=15 bits, true=7 bits).
    pub counter_step: bool,

    /// Dividing ratio of frequencies.
    pub divide_ratio: u8,
}

// TODO test
impl PolynomialCounter {
    /// Gets the result of reading the PolynomialCounter state for the current register state.
    pub fn read(&self) -> u8 {
        let mut byte = self.shift_clock_frequency << 4;
        byte |= self.divide_ratio;
        byte.set_bit(3, self.counter_step);

        byte
    }

    /// Modifies the PolynomialCounter state according to the written byte.
    pub fn write(&mut self, byte: u8) {
        self.shift_clock_frequency = byte >> 4;
        self.counter_step = byte.has_bit_set(3);
        self.divide_ratio = byte & 0x7;
    }
}

/// The counter/consecutive selection and initial flag.
#[derive(Debug, Default)]
pub struct InitialCounterConsecutive {
    /// Initial flag (true = restart sound) - write only.
    pub initial: bool,

    /// Counter/consecutive selection (true = stop output when length in NR41 expires).
    pub counter: bool,
}

// TODO test
impl InitialCounterConsecutive {
    /// Gets the result of reading the InitialCounterConsecutive state for the current register
    /// state.
    pub fn read(&self) -> u8 {
        let mut byte = 0;
        byte.set_bit(6, self.counter);

        byte
    }

    /// Modifies the InitialCounterConsecutive state according to the written byte.
    pub fn write(&mut self, byte: u8) {
        self.initial = byte.has_bit_set(7);
        self.counter = byte.has_bit_set(6);
    }
}

/// A single Game Boy square channel.
#[derive(Debug, Default)]
pub struct SquareChannel {
    /// Whether or not the sound is enabled.
    pub is_on: bool,

    /// Whether to output this sound to SO1 terminal.
    pub so1_enabled: bool,

    /// Whether to output this sound to SO2 terminal.
    pub so2_enabled: bool,

    /// The sweep register data.
    pub sweep: Sweep,

    /// The sound length/wave pattern data.
    pub wave: Wave,

    /// The volume envelope data.
    pub envelope: Envelope,

    /// The frequency data.
    pub frequency: Frequency,

    timer: u16,

    cycle_position: usize,

    output: u32,
}

impl SquareChannel {
    fn step(&mut self) {
        if self.timer > 0 {
            self.timer -= 1;
        } else {
            self.cycle_position += 1;
            if self.cycle_position == 8 {
                self.cycle_position = 0;
            }

            self.timer = (2048 - self.frequency.frequency) * 4;
        }

        self.output = if self.is_on {
            let wave = u32::from(DUTY[usize::from(self.wave.pattern)][self.cycle_position]);
            wave * u32::from(self.envelope.volume)
        } else {
            0
        };
    }

    /// Executes the [trigger event].
    ///
    /// [trigger event]: https://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Trigger_Event
    fn trigger(&mut self) {
        self.is_on = true;

        if self.wave.length == 0 {
            self.wave.length = 64;
        }

        // TODO: reload frequency timer

        self.envelope.counter = self.envelope.number;
        self.envelope.volume = self.envelope.initial_vol;

        // TODO: Handle disabled channel DAC
    }

    fn clock_length(&mut self) {
        if self.wave.step() {
            self.is_on = false;
        }
    }

    fn clock_envelope(&mut self) {
        self.envelope.step();
    }
}

/// Sound channel 3.
#[derive(Debug, Default)]
pub struct Sound3 {
    /// Whether or not the sound is enabled.
    pub is_on: bool,

    /// Whether to output this sound to SO1 terminal.
    pub so1_enabled: bool,

    /// Whether to output this sound to SO2 terminal.
    pub so2_enabled: bool,

    /// The volume level of this sound.
    pub output_level: OutputLevel,

    /// The sound length.
    pub length: BigLength,

    /// The frequency data.
    pub frequency: Frequency,

    /// The wave pattern memory for storing arbitrary sound data. Holds 32 4-bit samples.
    pub wave_pattern: [u8; 16],
}

/// Sound channel 4.
#[derive(Debug, Default)]
pub struct Sound4 {
    /// Whether or not the sound is enabled.
    pub is_on: bool,

    /// Whether to output this sound to the SO1 terminal.
    pub so1_enabled: bool,

    /// Whether to output this sound to the SO2 terminal.
    pub so2_enabled: bool,

    /// The sound length.
    pub length: Length,

    /// The volumne envelope data.
    pub envelope: Envelope,

    /// The polynomial counter.
    pub polynomial_counter: PolynomialCounter,

    /// The initial flag and counter/consecutive selection.
    pub initial_counter_consecutive: InitialCounterConsecutive,
}

/// The controller for the four sound channels output by the Game Boy. Also known as the APU (Audio
/// Processing Unit) or PAPU (Pseudo-Audio Processing Unit).
///
/// Generates [PCM audio samples] at the frequency of the APU and stores them in a ring buffer.
/// These samples are then downsampled to a rate acceptable by the computer hardware.
///
/// [PCM audio samples]: https://en.wikipedia.org/wiki/Pulse-code_modulation
#[derive(Debug)]
pub struct SoundController {
    /// Square 1: Rectangle waveform with sweep and envelope functions.
    pub square_1: SquareChannel,

    /// Square 2: Rectangle waveform with envelope function.
    pub square_2: SquareChannel,

    /// Sound 3: A waveform specificed by the waveform RAM.
    pub sound_3: Sound3,

    /// Sound 4: White noise with an envelope function.
    pub sound_4: Sound4,

    frame_sequencer: FrameSequencer,

    /// Toggle whether or not sound is enabled.
    pub sound_enabled: bool,

    /// The volume to output to the SO1 terminal.
    pub so1_vol: u8,

    /// The volume to output to the SO2 terminal.
    pub so2_vol: u8,

    /// Whether to output Vin to SO1.
    pub vin_so1: bool,

    /// Whether to output Vin to SO2.
    pub vin_so2: bool,

    /// Number of cycles since the last output sample.
    cycle_count: u32,

    /// Audio output. `None` if no output is desired.
    out: Option<Output>,
}

impl SoundController {
    /// Creates an emulated sound controller with no output.
    pub fn new() -> SoundController {
        SoundController {
            square_1: SquareChannel::default(),
            square_2: SquareChannel::default(),
            sound_3: Sound3::default(),
            sound_4: Sound4::default(),
            frame_sequencer: FrameSequencer::new(),
            sound_enabled: false,
            so1_vol: 0,
            so2_vol: 0,
            vin_so1: false,
            vin_so2: false,
            cycle_count: 0,
            out: None,
        }
    }

    /// Creates an emulated sound controller that plays audio.
    pub fn new_with_playback() -> Result<SoundController> {
        Ok(SoundController {
            out: Some(Output::new()?),
            ..Default::default()
        })
    }

    /// Ticks the audio output by a number of T-cycles.
    pub fn step(&mut self, cycles: TCycles) {
        for _ in 0..cycles.0 {
            if let Some(step) = self.frame_sequencer.step() {
                if step % 2 == 0 {
                    self.square_1.clock_length();
                    self.square_2.clock_length();
                }

                if step == 7 {
                    self.square_1.clock_envelope();
                    self.square_2.clock_envelope();
                }
            }

            self.square_1.step();
            self.square_2.step();

            if let Some(out) = &self.out {
                let mut sample = 0_f32;

                sample += self.square_1.output as f32 / 100_f32;
                sample += self.square_2.output as f32 / 100_f32;

                if self.cycle_count % out.decimation_factor == 0 {
                    out.sample_buffer.lock().unwrap().push_back(sample);
                    self.cycle_count = 0;
                }

                self.cycle_count += 1;
            }
        }
    }
}

impl Default for SoundController {
    fn default() -> Self {
        SoundController::new()
    }
}

impl Addressable for SoundController {
    /// Reads a byte of audio memory. Unreadable memory is always read as 1s.
    ///
    /// # Panics
    ///
    /// Panics if reading memory that is not managed by the sound controller.
    fn read_byte(&self, address: u16) -> u8 {
        // Access to sound registers, aside from 0xFF26, is disabled unless the sound is on.
        if !self.sound_enabled && address != 0xFF26 {
            return 0xFF;
        }

        match address {
            // NR10: Sound 1 sweep register
            // Bit 6-4 - Sweep time
            // Bit 3   - Sweep Increase/Decrease
            //            0: Addition    (frequency increases)
            //            1: Subtraction (frequency decreases)
            // Bit 2-0 - Number of sweep shift (n: 0-7)
            0xFF10 => self.square_1.sweep.read(),

            // NR11: Sound 1 Sound length/Wave pattern duty
            // Bit 7-6 - Wave pattern duty
            // Bit 5-0 - Sound length data (Write only)
            0xFF11 => self.square_1.wave.read(),

            // NR12: Channel 1 volume envelope
            // Bit 7-4 - Initial volume of the envelope (0-15) (0 = no sound)
            // Bit 3   - Envelope direction (0 = decrease, 1 = increase)
            // Bit 2-0 - Number of envelope sweep (n: 0-7) (If 0, stop the envelope operation)
            0xFF12 => self.square_1.envelope.read(),

            // NR13: Channel 1 frequency low
            // Unreadable.
            0xFF13 => 0xFF,

            // NR14: Channel 1 frequency high
            // Bit 7   - Initial (1 = restart sound) (write only)
            // Bit 6   - Counter/consecutive selection (1 = stop output when length in NR11
            //           expires)
            // Bit 2-0 - Frequency's higher 3 bits (write only)
            0xFF14 => self.square_1.frequency.read_hi(),

            // NR21: Sound 2 Sound length/Wave pattern duty
            // Bit 7-6 - Wave pattern duty
            // Bit 5-0 - Sound length data (Write only)
            0xFF16 => self.square_2.wave.read(),

            // NR22: Channel 2 volume envelope
            // Bit 7-4 - Initial volume of the envelope (0-15) (0 = no sound)
            // Bit 3   - Envelope direction (0 = decrease, 1 = increase)
            // Bit 2-0 - Number of envelope sweep (n: 0-7) (If 0, stop the envelope operation)
            0xFF17 => self.square_2.envelope.read(),

            // NR23: Channel 2 frequency low
            // Unreadable.
            0xFF18 => 0xFF,

            // NR24: Channel 2 frequency high
            // Bit 7   - Initial (1 = restart sound) (write only)
            // Bit 6   - Counter/consecutive selection (1 = stop output when length in NR21
            //           expires)
            // Bit 2-0 - Frequency's higher 3 bits (write only)
            0xFF19 => self.square_2.frequency.read_hi(),

            // NR30: Channel 3 sound on/off
            // Bit 7 - Sound channel 3 off (0=Stop, 1=Playback)
            0xFF1A => {
                if self.sound_3.is_on {
                    1
                } else {
                    0
                }
            }

            // NR31: Channel 3 sound length
            // Bit 7-0 - Sound length (0-255)
            0xFF1B => self.sound_3.length.read(),

            // NR32: Channel 3 select output level
            // Bit 6-5 - Select output level:
            //           0 - mute
            //           1 - 100% volume
            //           2 - 50% volume
            //           3 - 25% volume
            0xFF1C => self.sound_3.output_level.read(),

            // NR33: Channel 3 frequency low
            // Unreadable.
            0xFF1D => 0xFF,

            // NR34: Channel 3 frequency high
            // Bit 7   - Initial (1 = restart sound) (write only)
            // Bit 6   - Counter/consecutive selection (1 = stop output when length in NR11
            //           expires)
            // Bit 2-0 - Frequency's higher 3 bits (write only)
            0xFF1E => self.sound_3.frequency.read_hi(),

            // NR41: Channel 4 sound length
            // Bit 5-0 - Sound length data (0-63)
            0xFF20 => self.sound_4.length.read(),

            // NR42: Channel 4 volume envelope
            // Bit 7-4 - Initial volume of envelope (0=No sound)
            // Bit 3   - Envelope direction (0=Decrease, 1=Increase)
            // Bit 2-0 - Number of envelope sweep (If zero, stop envelope operation)
            0xFF21 => self.sound_4.envelope.read(),

            // NR43: Channel 4 polynomial counter
            // Bit 7-4 - Shift clock frequency
            // Bit 3   - Counter step/width (0=15 bits, 1=7 bits)
            // Bit 2-0 - Dividing ratio of frequencies
            0xFF22 => self.sound_4.polynomial_counter.read(),

            // NR44: Channel 4 counter/consecutive; initial
            // Bit 7 - Initial (1=restart sound) (write only)
            // Bit 6 - Counter/consecutive selection (1=Stop output when length in NR41 expires)
            0xFF23 => self.sound_4.initial_counter_consecutive.read(),

            // NR50: Channel control / ON-OFF / Volume
            // Specifies the master volume for Left/Right sound output.
            //
            // Bit 7    - Output Vin to SO2 terminal (1=Enable)
            // Bits 6-4 - SO2 output level (volume)  (0-7)
            // Bit 3    - Output Vin to SO1 terminal (1=Enable)
            // Bits 2-0 - SO1 output level (volume)  (0-7)
            0xFF24 => {
                let mut byte: u8 = self.so2_vol << 4;
                byte |= self.so1_vol;

                byte.set_bit(3, self.vin_so1);
                byte.set_bit(7, self.vin_so2);

                byte
            }

            // NR51: Selection of sound output terminal
            //
            // Bit 7 - Output sound 4 to SO2 terminal
            // Bit 6 - Output sound 3 to SO2 terminal
            // Bit 5 - Output sound 2 to SO2 terminal
            // Bit 4 - Output sound 1 to SO2 terminal
            // Bit 3 - Output sound 4 to SO1 terminal
            // Bit 2 - Output sound 3 to SO1 terminal
            // Bit 1 - Output sound 2 to SO1 terminal
            // Bit 0 - Output sound 1 to SO1 terminal
            0xFF25 => {
                let mut byte: u8 = 0;

                byte.set_bit(0, self.square_1.so1_enabled);
                byte.set_bit(4, self.square_1.so2_enabled);

                byte.set_bit(1, self.square_2.so1_enabled);
                byte.set_bit(5, self.square_2.so2_enabled);

                byte.set_bit(2, self.sound_3.so1_enabled);
                byte.set_bit(6, self.sound_3.so2_enabled);

                byte.set_bit(3, self.sound_4.so1_enabled);
                byte.set_bit(7, self.sound_4.so2_enabled);

                byte
            }

            // NR52: Sound on/off
            // Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
            //         Note that disabling sound destroys all the contents of the sound registers,
            //         and it is not possible to access any other sound registers while sound is
            //         disabled.
            // Bit 3 - Sound 4 ON flag (Read Only)
            // Bit 2 - Sound 3 ON flag (Read Only)
            // Bit 1 - Sound 2 ON flag (Read Only)
            // Bit 0 - Sound 1 ON flag (Read Only)
            0xFF26 => {
                let mut byte: u8 = 0xFF;

                byte.set_bit(0, self.square_1.is_on);
                byte.set_bit(1, self.square_2.is_on);
                byte.set_bit(2, self.sound_3.is_on);
                byte.set_bit(3, self.sound_4.is_on);

                byte.set_bit(7, self.sound_enabled);

                byte
            }

            // Channel 3 Wave pattern memory
            // Waveform storage for arbitrary sound data. Holds 32 4-bit samples, which are played
            // back upper 4 bits first.
            0xFF30..=0xFF3F => {
                let index = address - 0xFF30;
                self.sound_3.wave_pattern[index as usize]
            }

            _ => panic!(
                "read out-of-range address in the sound controller: {:#0x}",
                address
            ),
        }
    }

    /// Writes a byte of audio memory.
    ///
    /// # Panics
    ///
    /// Panics if writing memory that is not managed by the sound controller.
    fn write_byte(&mut self, address: u16, byte: u8) {
        // Access to sound registers, aside from 0xFF26, is disabled unless sound is on.
        if !self.sound_enabled && address != 0xFF26 {
            return;
        }

        match address {
            // NR10: Sound 1 sweep register
            // Bit 6-4 - Sweep time
            // Bit 3   - Sweep Increase/Decrease
            //            0: Addition    (frequency increases)
            //            1: Subtraction (frequency decreases)
            // Bit 2-0 - Number of sweep shift (n: 0-7)
            0xFF10 => self.square_1.sweep.write(byte),

            // NR11: Sound 1 Sound length/Wave pattern duty
            // Bit 7-6 - Wave pattern duty
            // Bit 5-0 - Sound length data (Write only)
            0xFF11 => self.square_1.wave.write(byte),

            // NR12: Channel 1 volume envelope
            // Bit 7-4 - Initial volume of the envelope (0-15) (0 = no sound)
            // Bit 3   - Envelope direction (0 = decrease, 1 = increase)
            // Bit 2-0 - Number of envelope sweep (n: 0-7) (If 0, stop the envelope operation)
            0xFF12 => self.square_1.envelope.write(byte),

            // NR13: Channel 1 Frequency low
            // Lower 8 bits of the 11-bit frequency
            0xFF13 => self.square_1.frequency.write_lo(byte),

            // NR14: Channel 1 frequency high
            // Bit 7   - Initial (1 = restart sound) (write only)
            // Bit 6   - Counter/consecutive selection (1 = stop output when length in NR11
            //           expires)
            // Bit 2-0 - Frequency's higher 3 bits (write only)
            0xFF14 => {
                if byte.has_bit_set(7) {
                    self.square_1.trigger();
                }

                self.square_1.wave.enabled = byte.has_bit_set(6);
                self.square_1.frequency.write_hi(byte);
            }

            // NR21: Sound 2 Sound length/Wave pattern duty
            // Bit 7-6 - Wave pattern duty
            // Bit 5-0 - Sound length data (Write only)
            0xFF16 => self.square_2.wave.write(byte),

            // NR22: Channel 2 volume envelope
            // Bit 7-4 - Initial volume of the envelope (0-15) (0 = no sound)
            // Bit 3   - Envelope direction (0 = decrease, 1 = increase)
            // Bit 2-0 - Number of envelope sweep (n: 0-7) (If 0, stop the envelope operation)
            0xFF17 => self.square_2.envelope.write(byte),

            // NR23: Channel 2 frequency low
            // Lower 8 bits of the 11-bit frequency
            0xFF18 => self.square_2.frequency.write_lo(byte),

            // NR24: Channel 2 frequency high
            // Bit 7   - Initial (1 = restart sound) (write only)
            // Bit 6   - Counter/consecutive selection (1 = stop output when length in NR21
            //           expires)
            // Bit 2-0 - Frequency's higher 3 bits (write only)
            0xFF19 => {
                if byte.has_bit_set(7) {
                    self.square_2.trigger();
                }
                self.square_2.wave.enabled = byte.has_bit_set(6);

                self.square_2.frequency.write_hi(byte);
            }

            // NR30: Channel 3 sound on/off
            // Bit 7 - Sound channel 3 off (0=Stop, 1=Playback)
            0xFF1A => self.sound_3.is_on = byte.has_bit_set(7),

            // NR31: Channel 3 sound length
            // Bit 7-0 - Sound length (0-255)
            0xFF1B => self.sound_3.length.write(byte),

            // NR32: Channel 3 select output level
            // Bit 6-5 - Select output level:
            //           0 - mute
            //           1 - 100% volume
            //           2 - 50% volume
            //           3 - 25% volume
            0xFF1C => self.sound_3.output_level.write(byte),

            // NR33: Channel 3 frequency low
            // Lower 8 bits of the 11-bit frequency
            0xFF1D => self.sound_3.frequency.write_lo(byte),

            // NR34: Channel 3 frequency high
            // Bit 7   - Initial (1 = restart sound) (write only)
            // Bit 6   - Counter/consecutive selection (1 = stop output when length in NR11
            //           expires)
            // Bit 2-0 - Frequency's higher 3 bits (write only)
            0xFF1E => self.sound_3.frequency.write_hi(byte),

            // NR41: Channel 4 sound length
            // Bit 5-0 - Sound length data (0-63)
            0xFF20 => self.sound_4.length.write(byte),

            // NR42: Channel 4 volume envelope
            // Bit 7-4 - Initial volume of envelope (0=No sound)
            // Bit 3   - Envelope direction (0=Decrease, 1=Increase)
            // Bit 2-0 - Number of envelope sweep (If zero, stop envelope operation)
            0xFF21 => self.sound_4.envelope.write(byte),

            // NR43: Channel 4 polynomial counter
            // Bit 7-4 - Shift clock frequency
            // Bit 3   - Counter step/width (0=15 bits, 1=7 bits)
            // Bit 2-0 - Dividing ratio of frequencies
            0xFF22 => self.sound_4.polynomial_counter.write(byte),

            // NR44: Channel 4 counter/consecutive; initial
            // Bit 7 - Initial (1=restart sound) (write only)
            // Bit 6 - Counter/consecutive selection (1=Stop output when length in NR41 expires)
            0xFF23 => self.sound_4.initial_counter_consecutive.write(byte),

            // NR50: Channel control / ON-OFF / Volume
            // Specifies the master volume for Left/Right sound output.
            //
            // Bit 7    - Output Vin to SO2 terminal (1=Enable)
            // Bits 6-4 - SO2 output level (volume)  (0-7)
            // Bit 3    - Output Vin to SO1 terminal (1=Enable)
            // Bits 2-0 - SO1 output level (volume)  (0-7)
            0xFF24 => {
                self.so1_vol = byte & 0x7;
                self.vin_so1 = byte.has_bit_set(3);

                self.so2_vol = (byte >> 4) & 0x7;
                self.vin_so2 = byte.has_bit_set(7);
            }

            // NR51: Selection of sound output terminal
            //
            // Bit 7 - Output sound 4 to SO2 terminal
            // Bit 6 - Output sound 3 to SO2 terminal
            // Bit 5 - Output sound 2 to SO2 terminal
            // Bit 4 - Output sound 1 to SO2 terminal
            // Bit 3 - Output sound 4 to SO1 terminal
            // Bit 2 - Output sound 3 to SO1 terminal
            // Bit 1 - Output sound 2 to SO1 terminal
            // Bit 0 - Output sound 1 to SO1 terminal
            0xFF25 => {
                self.square_1.so1_enabled = byte.has_bit_set(0);
                self.square_1.so2_enabled = byte.has_bit_set(4);

                self.square_2.so1_enabled = byte.has_bit_set(1);
                self.square_2.so2_enabled = byte.has_bit_set(5);

                self.sound_3.so1_enabled = byte.has_bit_set(2);
                self.sound_3.so2_enabled = byte.has_bit_set(6);

                self.sound_4.so1_enabled = byte.has_bit_set(3);
                self.sound_4.so2_enabled = byte.has_bit_set(7);
            }

            // NR52: Sound on/off
            // Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
            //         Note that disabling sound destroys all the contents of the sound registers,
            //         and it is not possible to access any other sound registers while sound is
            //         disabled.
            // Bit 3 - Sound 4 ON flag (Read Only)
            // Bit 2 - Sound 3 ON flag (Read Only)
            // Bit 1 - Sound 2 ON flag (Read Only)
            // Bit 0 - Sound 1 ON flag (Read Only)
            0xFF26 => {
                self.sound_enabled = byte.has_bit_set(7);

                if !self.sound_enabled {
                    self.square_1 = SquareChannel::default();
                    self.square_2 = SquareChannel::default();
                    self.sound_3 = Sound3::default();
                    self.sound_4 = Sound4::default();
                }
            }

            // Channel 3 Wave pattern memory
            // Waveform storage for arbitrary sound data. Holds 32 4-bit samples, which are played
            // back upper 4 bits first.
            0xFF30..=0xFF3F => {
                let index = address - 0xFF30;
                self.sound_3.wave_pattern[index as usize] = byte;
            }

            _ => panic!(
                "write out-of-range address in the sound controller: {:#0x}",
                address
            ),
        }
    }
}

#[cfg(test)]
mod tests {
    use std::u8;

    use proptest::proptest;

    use crate::bytes::ByteExt;
    use crate::memory::Addressable;

    use super::{Frequency, SoundController, Sweep};

    #[test]
    fn sweep_read() {
        let mut sweep = Sweep::default();

        for shift_num in 0..8 {
            for inc_dec in 0..2 {
                for time in 0..8 {
                    let expected = (time << 4) | (inc_dec << 3) | shift_num;

                    sweep.time = time;
                    sweep.decrease = if inc_dec == 1 { true } else { false };
                    sweep.shift = shift_num;

                    assert_eq!(sweep.read(), expected);
                }
            }
        }
    }

    #[test]
    fn sweep_write() {
        let mut sweep = Sweep::default();

        for shift_num in 0..8 {
            for inc_dec in 0..2 {
                for time in 0..8 {
                    for extra in 0..2 {
                        let byte = (extra << 7) | (time << 4) | (inc_dec << 3) | shift_num;

                        let expected_time = time;
                        let expected_decrease = if inc_dec == 1 { true } else { false };
                        let expected_shift = shift_num;

                        sweep.write(byte);

                        assert_eq!(sweep.time, expected_time);
                        assert_eq!(sweep.decrease, expected_decrease);
                        assert_eq!(sweep.shift, expected_shift);
                    }
                }
            }
        }
    }

    #[test]
    fn frequency_write_low() {
        let mut frequency = Frequency::default();

        for freq in 0..4096 {
            let byte = (freq & 0xFF) as u8;

            frequency.write_lo(byte);

            assert_eq!((frequency.frequency & 0xFF) as u8, byte);

            frequency.frequency = 4095;
            frequency.write_lo(byte);

            assert_eq!((frequency.frequency & 0xFF) as u8, byte);
        }
    }

    #[test]
    fn frequency_read_high() {
        let mut frequency = Frequency::default();

        for initial in 0..2 {
            for counter in 0..2 {
                for freq in 0..4096 {
                    let mut expected = 0xFF;
                    expected.set_bit(6, counter == 1);

                    frequency.initial = if initial == 1 { true } else { false };
                    frequency.counter = if counter == 1 { true } else { false };
                    frequency.frequency = freq;

                    assert_eq!(frequency.read_hi(), expected);
                }
            }
        }
    }

    #[test]
    fn frequency_write_high() {
        let mut frequency = Frequency::default();

        for initial in 0..2 {
            for counter in 0..2 {
                for freq in 0..4096 {
                    let byte = (initial << 7) | (counter << 6) | (((freq >> 8) as u8) & 0x7);

                    let expected_initial = if initial == 1 { true } else { false };
                    let expected_counter = if counter == 1 { true } else { false };
                    let expected_frequency = freq & 0x0700;

                    frequency.write_hi(byte);

                    assert_eq!(frequency.initial, expected_initial);
                    assert_eq!(frequency.counter, expected_counter);
                    assert_eq!(frequency.frequency, expected_frequency);
                }
            }
        }
    }

    #[test]
    fn ff24_read() {
        let mut sc = SoundController::new();

        for so1_vol in 0..8 {
            for so2_vol in 0..8 {
                for vin_so1 in vec![false, true] {
                    for vin_so2 in vec![false, true] {
                        sc.so1_vol = so1_vol;
                        sc.so2_vol = so2_vol;
                        sc.vin_so1 = vin_so1;
                        sc.vin_so2 = vin_so2;

                        let mut expected = 0;
                        expected.set_bit(0, so1_vol.has_bit_set(0));
                        expected.set_bit(1, so1_vol.has_bit_set(1));
                        expected.set_bit(2, so1_vol.has_bit_set(2));
                        expected.set_bit(3, vin_so1);
                        expected.set_bit(4, so2_vol.has_bit_set(0));
                        expected.set_bit(5, so2_vol.has_bit_set(1));
                        expected.set_bit(6, so2_vol.has_bit_set(2));
                        expected.set_bit(7, vin_so2);

                        sc.sound_enabled = false;
                        assert_eq!(sc.read_byte(0xFF24), 0xFF);

                        sc.sound_enabled = true;
                        assert_eq!(sc.read_byte(0xFF24), expected);
                    }
                }
            }
        }
    }

    #[test]
    fn ff24_write() {
        let mut sc = SoundController::new();

        for so1_vol in 0..8 {
            for so2_vol in 0..8 {
                for vin_so1 in vec![false, true] {
                    for vin_so2 in vec![false, true] {
                        sc.so1_vol = 0;
                        sc.so2_vol = 0;
                        sc.vin_so1 = false;
                        sc.vin_so2 = false;

                        let mut byte = so1_vol & (so2_vol << 4);
                        byte.set_bit(0, so1_vol.has_bit_set(0));
                        byte.set_bit(1, so1_vol.has_bit_set(1));
                        byte.set_bit(2, so1_vol.has_bit_set(2));
                        byte.set_bit(3, vin_so1);
                        byte.set_bit(4, so2_vol.has_bit_set(0));
                        byte.set_bit(5, so2_vol.has_bit_set(1));
                        byte.set_bit(6, so2_vol.has_bit_set(2));
                        byte.set_bit(7, vin_so2);

                        sc.sound_enabled = false;
                        sc.write_byte(0xFF24, byte);

                        assert_eq!(sc.so1_vol, 0);
                        assert_eq!(sc.so2_vol, 0);
                        assert_eq!(sc.vin_so1, false);
                        assert_eq!(sc.vin_so2, false);

                        sc.sound_enabled = true;
                        sc.write_byte(0xFF24, byte);

                        assert_eq!(sc.so1_vol, so1_vol);
                        assert_eq!(sc.so2_vol, so2_vol);
                        assert_eq!(sc.vin_so1, vin_so1);
                        assert_eq!(sc.vin_so2, vin_so2);
                    }
                }
            }
        }
    }

    #[test]
    fn ff25_read() {
        let mut sc = SoundController::new();

        for i_large in 0usize..256 {
            let i = i_large as u8;

            sc.square_1.so1_enabled = i.has_bit_set(0);
            sc.square_1.so2_enabled = i.has_bit_set(4);

            sc.square_2.so1_enabled = i.has_bit_set(1);
            sc.square_2.so2_enabled = i.has_bit_set(5);

            sc.sound_3.so1_enabled = i.has_bit_set(2);
            sc.sound_3.so2_enabled = i.has_bit_set(6);

            sc.sound_4.so1_enabled = i.has_bit_set(3);
            sc.sound_4.so2_enabled = i.has_bit_set(7);

            sc.sound_enabled = false;
            assert_eq!(sc.read_byte(0xFF25), 0xFF);

            sc.sound_enabled = true;
            assert_eq!(sc.read_byte(0xFF25), i);
        }
    }

    #[test]
    fn ff25_write() {
        let mut sc = SoundController::new();

        for i_large in 0usize..256 {
            let i = i_large as u8;

            // Make up a default state - writing with sound disabled shouldn't change this
            sc.square_1.so1_enabled = false;
            sc.square_1.so2_enabled = false;

            sc.square_2.so1_enabled = true;
            sc.square_2.so2_enabled = false;

            sc.sound_3.so1_enabled = false;
            sc.sound_3.so2_enabled = true;

            sc.sound_4.so1_enabled = true;
            sc.sound_4.so2_enabled = true;

            sc.sound_enabled = false;
            sc.write_byte(0xFF25, i);

            assert_eq!(sc.square_1.so1_enabled, false);
            assert_eq!(sc.square_1.so2_enabled, false);

            assert_eq!(sc.square_2.so1_enabled, true);
            assert_eq!(sc.square_2.so2_enabled, false);

            assert_eq!(sc.sound_3.so1_enabled, false);
            assert_eq!(sc.sound_3.so2_enabled, true);

            assert_eq!(sc.sound_4.so1_enabled, true);
            assert_eq!(sc.sound_4.so2_enabled, true);

            sc.sound_enabled = true;
            sc.write_byte(0xFF25, i);

            assert_eq!(sc.square_1.so1_enabled, i.has_bit_set(0));
            assert_eq!(sc.square_1.so2_enabled, i.has_bit_set(4));

            assert_eq!(sc.square_2.so1_enabled, i.has_bit_set(1));
            assert_eq!(sc.square_2.so2_enabled, i.has_bit_set(5));

            assert_eq!(sc.sound_3.so1_enabled, i.has_bit_set(2));
            assert_eq!(sc.sound_3.so2_enabled, i.has_bit_set(6));

            assert_eq!(sc.sound_4.so1_enabled, i.has_bit_set(3));
            assert_eq!(sc.sound_4.so2_enabled, i.has_bit_set(7));
        }
    }

    #[test]
    fn ff26_read() {
        let mut sc = SoundController::new();

        for i in 0u8..32 {
            let mut expected: u8 = i | 0xF0;
            expected.set_bit(7, i.has_bit_set(4));

            sc.square_1.is_on = i.has_bit_set(0);
            sc.square_2.is_on = i.has_bit_set(1);
            sc.sound_3.is_on = i.has_bit_set(2);
            sc.sound_4.is_on = i.has_bit_set(3);
            sc.sound_enabled = i.has_bit_set(4);

            assert_eq!(sc.read_byte(0xFF26), expected);
        }
    }

    #[test]
    fn ff26_write() {
        // TODO: need to test that sound registers are cleared
        let mut sc = SoundController::new();

        for i_large in 0usize..256 {
            let i = i_large as u8;

            sc.write_byte(0xFF26, i);

            assert_eq!(sc.sound_enabled, i.has_bit_set(7));
        }
    }

    proptest! {
        #[test]
        fn nr11(duty in 0u8..4, length_load in 0u8..64) {
            let mut apu = SoundController::new();
            apu.write_byte(0xFF26, 0xFF);

            let byte = duty << 6 | length_load;

            apu.write_byte(0xFF11, byte);
            assert_eq!(apu.square_1.wave.pattern, duty);
            assert_eq!(apu.square_1.wave.length_load, length_load);
            assert_eq!(apu.square_1.wave.length, 64 - length_load);

            assert_eq!(apu.read_byte(0xFF11), byte);
        }

        #[test]
        fn nr12(starting_volume in 0u8..16, add_mode in 0u8..2, period in 0u8..8) {
            let mut apu = SoundController::new();
            apu.write_byte(0xFF26, 0xFF);

            let byte = starting_volume << 4 | add_mode << 3 | period;

            apu.write_byte(0xFF12, byte);
            assert_eq!(apu.square_1.envelope.initial_vol, starting_volume);
            assert_eq!(apu.square_1.envelope.direction_increase as u8, add_mode);
            assert_eq!(apu.square_1.envelope.number, period);

            assert_eq!(apu.read_byte(0xFF12), byte);
        }

        #[test]
        fn nr21(duty in 0u8..4, length_load in 0u8..64) {
            let mut apu = SoundController::new();
            apu.write_byte(0xFF26, 0xFF);

            let byte = duty << 6 | length_load;

            apu.write_byte(0xFF16, byte);
            assert_eq!(apu.square_2.wave.pattern, duty);
            assert_eq!(apu.square_2.wave.length_load, length_load);
            assert_eq!(apu.square_2.wave.length, 64 - length_load);

            assert_eq!(apu.read_byte(0xFF16), byte);
        }

        #[test]
        fn nr22(starting_volume in 0u8..16, add_mode in 0u8..2, period in 0u8..8) {
            let mut apu = SoundController::new();
            apu.write_byte(0xFF26, 0xFF);

            let byte = starting_volume << 4 | add_mode << 3 | period;

            apu.write_byte(0xFF17, byte);
            assert_eq!(apu.square_2.envelope.initial_vol, starting_volume);
            assert_eq!(apu.square_2.envelope.direction_increase as u8, add_mode);
            assert_eq!(apu.square_2.envelope.number, period);

            assert_eq!(apu.read_byte(0xFF17), byte);
        }
    }
}
